<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tensor Tiling Library: Pipelining DMA Tiled Loops</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="tensor_tiling_library_slim.png"/></td>
  <td id="projectalign">
   <div id="projectname">Tensor Tiling Library
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_v7F17Om__TTL_2doc_2tutorials_2pipelining__dma__tiled__loops_2pipelining__dma__tiled__loops.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Pipelining DMA Tiled Loops</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>CONTENTS: </h1>
<ul>
<li>Pipelining DMA Tiled Loops<ul>
<li>Introduction</li>
<li>Maximizing performance</li>
<li>Appendix: full pipeline description</li>
</ul>
</li>
</ul>
<h1>Introduction</h1>
<p>As a simple example suppose a single input image is imported, operated on, and exported. Tiling produces a single “outer” loop which conceptually processes one tile per iteration:</p>
<div class="fragment"><div class="line">// 0. Non-pipelined tiled loop</div>
<div class="line">for tile in [0, number_of_tiles]</div>
<div class="line">  Import tile</div>
<div class="line">  WaitImport tile</div>
<div class="line">  Compute tile</div>
<div class="line">  Export tile</div>
<div class="line">  WaitExport tile</div>
</div><!-- fragment --><p>Software-Pipelining a tiled loop can overlap independent operations across iterations and execute them concurrently, similar to pipelining the instructions of innermost loop(s) producing parallel instruction bundles for VLIW targets Modulo-Scheduling is an automatic pipelining technique which maximizes parallelism and throughput by minimizing the latency of the steady state, aka Initiation Interval (II), and then applying variable expansion as needed - allocating multiple rotating registers to values whose live-range exceeds II. The concurrency in DMA-Tiled loops stems from the asynchronous and independent nature of DMA operations, rather than the Instruction-Level Parallelism of VLIWs. On many accelerators, a DMA import and/or export can run in parallel to independent non-DMA SSC operations. Buffers allocated on scratchpad memory whose pipelined live-ranges self-intersect, i.e., exceed the initiation interval, require Array Expansion (across distinct memory banks), similar to allocating multiple rotating registers.</p>
<p>It is also conceivable to combine manual Tiling with automated Pipelining, coupled with manual or automated expansion. One such combination is initially outlined below. Automated steps could be assisted by user directive, as in #pragma disable_loop_pipelining of Intel FPGA SDK for OpenCL.</p>
<h1>Maximizing performance</h1>
<p>The above chain of 5 operations: Import &ndash;&gt; WaitImport &ndash;&gt; Compute &ndash;&gt; Export &ndash;&gt; WaitExport can be maximally pipeline-parallelized by assigning Import, Export and Compute to three distinct pipeline stages: starting to import the next tile in parallel to computing the current tile, and in parallel to exporting the previously computed tile</p>
<div class="fragment"><div class="line">// Conceptual 3-stage Pipeline </div>
<div class="line">// II = max {|Import|, |Export|, |Compute|}</div>
<div class="line"> </div>
<div class="line">Iteration:          1        2        3+</div>
<div class="line">---------------+--------+--------+--------</div>
<div class="line">Prolog Stage 1: Import1</div>
<div class="line">               --------</div>
<div class="line">Prolog Stage 2: Compute1 Import2</div>
<div class="line">                -------- --------</div>
<div class="line">Steady State:   Export1  Compute2 Import3</div>
<div class="line">                -------- -------- --------</div>
<div class="line">Epilog Stage 1:          Export2  Compute3</div>
<div class="line">                         -------- --------</div>
<div class="line">Epilog Stage 2:                   Export3</div>
</div><!-- fragment --><p>The buffer associated with Import has a live-range spanning two iterations: starting at the Import operation and ending when the associated Compute finishes to consume the buffer. The buffer associated with Export also has a live-range spanning two iterations: starting at the associated Compute operation and ending when Export finishes. Therefore, each requires double-buffering.</p>
<p>Q: When should WaitImport and WaitExport be scheduled? Their latency is expected to be negligible compared to that of the actual Import and Export.</p>
<p>A: In general, on non-VLIW targets such as SSC, operations scheduled to run together in parallel bundles need to be ordered in order to achieve the desired concurrency. The parallel bundle in the above example:</p>
<div class="fragment"><div class="line">[Export-previous-tile || Computing-current-tile || Import-next-tile]</div>
</div><!-- fragment --><p>whose operations conceptually overlap by starting together and finishing together, should be ordered such that Import and Export are issued before Compute, which in turn is issued before WaitImport and WaitExport. Doing so produces</p>
<div class="fragment"><div class="line">// 1a. “Earliest Waits” double double-buffered pipeline</div>
<div class="line">for (tile)</div>
<div class="line">  Export tile-1; Import tile+1; Compute tile; WaitImport tile+1; WaitExport tile-1</div>
</div><!-- fragment --><p>Q0: Should WaitImport and/or WaitExport tile-1 be scheduled later?</p>
<p>A0: Pipelining optimizes the schedule according to latency estimates, so synchronizing at the end of each “line” is expected to be quick. But it may be advantageous to tolerate potential delays in DMA transactions by postponing their synchronizing waits, provided resources are available to do so - including associated scratchpad buffer (on available memory bank) and DMA channel.</p>
<p>Rotating WaitImport tile+1 and WaitExport tile-1 forward from being the last operations of the iteration, to being the first operations of the next iteration, produces the equivalent pipeline with one additional stage and iteration:</p>
<div class="fragment"><div class="line">// 1b. Rotated “Earliest Waits” double double-buffered pipeline</div>
<div class="line">for (tile)</div>
<div class="line">  WaitImport tile; WaitExport tile-2; Export tile-1; Import tile+1; Compute tile </div>
</div><!-- fragment --><p>Postponing WaitImport tile to appear after WaitExport, Export, and right before Import tile+1 produces</p>
<div class="fragment"><div class="line">// 2. “Wait before next Import/Export” pipeline</div>
<div class="line">for (tile)</div>
<div class="line">  WaitExport tile-2; Export tile-1; WaitImport tile; Import tile+1; Compute tile </div>
</div><!-- fragment --><p>This is the pipeline produced by dmaiterate, and should be used when analyzing performance comparison between dmaiterate and manual/TTL tiling (see Appendix A in “To Tiler Or Not To Tiler”).</p>
<p>Postponing WaitImport and WaitExport further/furthest, to appear before the dependent Compute produces</p>
<div class="fragment"><div class="line">// 3. “Latest Waits” pipeline</div>
<div class="line">for (tile)</div>
<div class="line">  Export tile-1; Import tile+1; WaitImport tile; WaitExport tile-2; Compute tile</div>
</div><!-- fragment --><p>A full pipeline description is provided in an Appendix below.</p>
<p>Q1: If WaitImport tile and Import tile+1, are scheduled back-to-back, who should go first?</p>
<p>A1: placing WaitImport tile first allows both to reuse the same channel. If WaitImport tile stalls - because the import of tile is yet to complete, issuing Import tile+1 early will not gain much (if anything?) given that all imports are DMA’d in-order on any device. Same goes for scheduling WaitExport tile-2 relative to Export tile-1.</p>
<p>Q2: Should WaitImport tile be scheduled after Export tile-1, or before it?</p>
<p>A2: When hardware allows it may be advantageous to schedule Export tile-1 first before WaitImport tile which may stall, if there are available channels. Same goes for scheduling WaitExport tile-2 relative to Import tile+1.</p>
<p>Q3: Should WaitImport tile and WaitExport tile-2 be combined into a single wait on both channels, instead of two separate waits scheduled back to back?</p>
<p>A3: probably yes, resulting in a single DMA/SSC synchronization point instead of two(?)</p>
<p>Q3.5: How should the above example be pipelined, if fewer than four buffers/banks are available?</p>
<p>A3.5: With fewer than four buffers, at most two of {Compute, Import, Export} can overlap, implying that II will be at-least “2”. At-least two distinct buffers are required by Compute, assuming it cannot write destructively to the same buffer it reads from.</p>
<p>Overlapping Import with Export is possible and requires (only the) two buffers:</p>
<div class="fragment"><div class="line">// Conceptual 2-stage Pipeline with Duplex DMA</div>
<div class="line">// W/o any double-buffering</div>
<div class="line">// II = |Compute| + max {|Import|, |Export|}</div>
<div class="line"> </div>
<div class="line">Iteration:          1        2+</div>
<div class="line">---------------+--------+--------+</div>
<div class="line">Prolog Stage 1: Import1</div>
<div class="line">                Compute1</div>
<div class="line">               --------</div>
<div class="line">Steady State:   Export1  Import2</div>
<div class="line">                         Compute2</div>
<div class="line">                -------- --------</div>
<div class="line">Epilog Stage 1:          Export2</div>
</div><!-- fragment --><p>If Import is not overlapped with Export, either or both could be overlapped with Compute, requiring a third buffer for double or triple buffering, respectively. Doing so also addresses the following related question:</p>
<p>Q4: How should the above example be pipelined when duplex DMA is not possible</p>
<p>A4: There are several pipelining options, depending on the latency of Compute relative to that of Import and Export</p>
<p>A4.1: Overlap Compute with Import; good when |Compute| &lt;= |Import|</p>
<div class="fragment"><div class="line">// Conceptual 2-stage Pipeline with Simplex DMA</div>
<div class="line">// II = |Export| + max {|Compute|, |Import|}</div>
<div class="line">// Import is double-buffered but Export is not</div>
<div class="line"> </div>
<div class="line">Iteration:          1        2+</div>
<div class="line">---------------+--------+--------+</div>
<div class="line">Prolog Stage 1: Import1</div>
<div class="line"> </div>
<div class="line">Steady State:   Compute1 Import2</div>
<div class="line">                Export1</div>
<div class="line">Epilog Stage 1:          Compute2</div>
<div class="line">                         Export2  </div>
</div><!-- fragment --><p>A4.2: Overlap Compute with Export; good when |Compute| &lt;= |Export|</p>
<div class="fragment"><div class="line">// Conceptual 2-stage Pipeline with Simplex DMA</div>
<div class="line">// II = |Import| + max {|Compute|, |Export|}</div>
<div class="line">// Export is double-buffered but Import is not</div>
<div class="line"> </div>
<div class="line">Iteration:          1        2+</div>
<div class="line">---------------+--------+--------+</div>
<div class="line">Prolog Stage 1: Import1</div>
<div class="line">                Compute1</div>
<div class="line">Steady State:            Import2</div>
<div class="line">                Export1  Compute2</div>
<div class="line">Epilog Stage 1:          </div>
<div class="line">                         Export2  </div>
</div><!-- fragment --><p>Q5: If |Compute| &lt;= min {|Input|, |Export|}, which of A4.1 and A4.2 is better?</p>
<p>A5: their II’s in this case are equal: |Input|+|Export|; double-buffering the smaller buffer (of Import and Export) would save scratchpad memory space.</p>
<p>A4.3: Overlap Compute with both Import and Export; good also when |Compute| &gt; max {|Import|, |Export|}</p>
<div class="fragment"><div class="line">// Conceptual 3-stage Pipeline with Simplex DMA</div>
<div class="line">// II = max {|Compute|, |Import|+|Export|}</div>
<div class="line">// Import and Export are triple-buffered together</div>
<div class="line"> </div>
<div class="line">Iteration:          1        2+</div>
<div class="line">---------------+--------+--------+</div>
<div class="line">Prolog Stage 1:</div>
<div class="line">                Import1                   </div>
<div class="line">Prolog Stage 2: Compute1                  -+ Live-range of</div>
<div class="line">                (cont’d) Import2           | exported buffer</div>
<div class="line">Steady State:   Export1  Compute2         -+ </div>
<div class="line">                         (cont’d) Import3  -+ Live-range of</div>
<div class="line">Epilog Stage 1:          Export2  Compute3  | imported buffer</div>
<div class="line">                                  (cont’d) -+</div>
<div class="line">Epilog Stage 2:                   Export3</div>
</div><!-- fragment --><p>Note: A4.3 can be applied instead of A4.1 and A4.2 when |Compute| &lt;= |Import| and |Compute| &lt;= |Export|, respectively: they have the same II of |Input|+|Export|. The triple-buffering of A4.3 requires three buffers all having the size of the larger buffer (between Import and Export), whereas A4.1 and A4.2 require smaller scratchpad memory space if Import and Export buffers are of distinct sizes.</p>
<p>Note: triple-buffering advocates the use of duplex DMA which may reduce the II from max {|Compute|, |Input|+|Export|} potentially close to max {|Compute|,|Input|,|Export|}.</p>
<p>Note: if Compute can be partitioned, the loop can be rotated to produce a 2-staged pipeline</p>
<div class="fragment"><div class="line">// Conceptual 2-stage Rotated Pipeline with Simplex DMA</div>
<div class="line">// II = max {|Compute|, |Import|+|Export|}</div>
<div class="line">// Import and Export are triple-buffered together</div>
<div class="line"> </div>
<div class="line">Iteration:          1        2+</div>
<div class="line">---------------+--------+--------+</div>
<div class="line">Prolog Stage 1: Import1</div>
<div class="line">                CompuA1                   </div>
<div class="line">Steady State:   CompuB1  Import2</div>
<div class="line">                Export1  CompuA2</div>
<div class="line">Epilog Stage 1:          CompuB2 </div>
<div class="line">                         Export2</div>
</div><!-- fragment --><h1>Appendix: full pipeline description</h1>
<p>Including WaitImport tile and WaitExport in the pipeline, having a single column for single-issue targets such as SSC, produces the following for the above example, using an estimate of100 cycles for each DMA transaction and computation:</p>
<div class="fragment"><div class="line">  // 3a. “Latest Waits” pipeline: full description</div>
<div class="line"> </div>
<div class="line">  0              -+</div>
<div class="line">  1    Import0    |</div>
<div class="line">  2               | Prolog Stage 1</div>
<div class="line">  3               |</div>
<div class="line">  4              -+</div>
<div class="line">100                -+</div>
<div class="line">101       Import1   |</div>
<div class="line">102    WaitImport0  | Prolog Stage 2</div>
<div class="line">103                 |</div>
<div class="line">104    Compute0    -+</div>
<div class="line">200    Export0        -+</div>
<div class="line">201          Import2   |</div>
<div class="line">202       WaitImport1  | Prolog Stage 3</div>
<div class="line">203                    |</div>
<div class="line">204       Compute1    -+</div>
<div class="line">300       Export1        -+</div>
<div class="line">301             Import3   |</div>
<div class="line">302          WaitImport2  | Steady State</div>
<div class="line">303    WaitExport0        |</div>
<div class="line">304          Compute2    -+</div>
<div class="line">400          Export2        -+</div>
<div class="line">401                          |</div>
<div class="line">402             WaitImport3  | Epilog Stage 1</div>
<div class="line">403       WaitExport1        |</div>
<div class="line">404             Compute3    -+</div>
<div class="line">500             Export3     -+</div>
<div class="line">501                          |</div>
<div class="line">502                          | Epilog Stage 2</div>
<div class="line">503          WaitExport2     |</div>
<div class="line">504                         -+</div>
<div class="line">600                         -+</div>
<div class="line">601                          |</div>
<div class="line">602                          | Epilog Stage 3</div>
<div class="line">603             WaitExport3  |</div>
<div class="line">604                         -+</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
